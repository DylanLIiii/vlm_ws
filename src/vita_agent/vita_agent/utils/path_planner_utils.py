import numpy as np
import cv2
import time


class PathFinderController:
    """Simple P-Controller."""

    def __init__(self, kp_rho, kp_alpha):
        self.kp_rho = kp_rho
        self.kp_alpha = kp_alpha

    def calc_control_command(self, x_diff, y_diff, theta):

        rho = np.hypot(x_diff, y_diff)
        alpha = (np.arctan2(y_diff, x_diff) - theta + np.pi) % (2 * np.pi) - np.pi

        v = self.kp_rho * rho
        w = self.kp_alpha * alpha

        return rho, v, w
    

def check_collision_free(x_traj_grid, y_traj_grid, occ_map):
    """Check if all way points within bounds and not in collision."""

    # if (x_traj_grid < 0).any() or (x_traj_grid >= occ_map.shape[0]).any() or (y_traj_grid < 0).any() or (y_traj_grid >= occ_map.shape[1]).any():
    #     return False
    # if (occ_map[y_traj_grid, x_traj_grid] < 1).any():
    #     return False
    # return True



    x_indices = np.round(x_traj_grid).astype(int)
    y_indices = np.round(y_traj_grid).astype(int)
    if (y_indices < 0).any() or (y_indices >= occ_map.shape[0]).any() or \
        (x_indices < 0).any() or (x_indices >= occ_map.shape[1]).any():
        return False
    if (occ_map[y_indices, x_indices] > 0).any():
        return False
    return True

    # for i in range(len(x_traj_grid)):
    #     if round(y_traj_grid[i]) < 0 or round(y_traj_grid[i]) >= occ_map.shape[1] or round(x_traj_grid[i]) < 0 or round(x_traj_grid[i]) >= occ_map.shape[0]:
    #         return False # occ
    #     if occ_map[round(y_traj_grid[i]), round(x_traj_grid[i])] < 1:
    #         return False # occ
        
    # return True # no occ, pass check


def sample_path(collision_results, occ_map=None, x_traj_grid_list=None, y_traj_grid_list=None, importance_sampling=False, use_safety_score=False):
    """Sample a path from the collision free paths."""
    collision_free_list = [index for index, value in enumerate(collision_results) if value is True]
    if len(collision_free_list) == 0:
        return -1
    else:
        if importance_sampling:
            # Probability of sampling, 
            # high probability means high sampling rate when almost all paths are collision free
            q = len(collision_free_list) / (len(collision_results) + 1) 
            s = 0
            p = [0]
            for i in range(len(collision_free_list)):
                s += (1 - q) ** (i + 1)
                p.append(s)

            # normalize the probability
            for i in range(len(p)):
                p[i] = p[i] / p[-1]

            # sample a path
            r = np.random.random()
            for i in range(len(p)):
                if r < p[i]:
                    return collision_free_list[i - 1]

        elif use_safety_score:
            # Calculate safety scores for each collision-free path
            safety_scores = []

            for idx in collision_free_list:
                x_traj = x_traj_grid_list[idx]
                y_traj = y_traj_grid_list[idx]
                score = calculate_safety_score(x_traj, y_traj, occ_map)
                safety_scores.append((idx, score))

            # Sort paths by safety score (higher is better) and index (lower is better)
            safety_scores.sort(key=lambda x: (-x[1], x[0]))  # 使用负的score使得分数高的在前，同分数时idx小的在前
            return safety_scores[0][0]  # Return the path with highest safety score (and lowest index if tied)

        else:
            # Select the first collision free path, 
            # which is the most similar to the path generated by the global planner
            return collision_free_list[0]


def calculate_safety_score(x_traj, y_traj, occ_map):
    """Calculate safety score for a trajectory based on distance to obstacles."""
    x_indices = np.round(x_traj).astype(int)
    y_indices = np.round(y_traj).astype(int)
    
    score = 0
    kernel_size = 3  # Size of the area to check around each point (path dilation), we hard code the kernel size here. 
    
    for x, y in zip(x_indices, y_indices):
        # Check surrounding area for obstacles
        x_min = max(0, x - kernel_size)
        x_max = min(occ_map.shape[1], x + kernel_size + 1)
        y_min = max(0, y - kernel_size)
        y_max = min(occ_map.shape[0], y + kernel_size + 1)
        
        # Count free cells in surrounding area
        area = occ_map[y_min:y_max, x_min:x_max]
        free_cells = (area == 0).sum()
        score += free_cells
    
    return score




def generate_local_yaw_rate(rot_steps, rot_step_size):
    local_w_list = [0]
    for i in range(1, rot_steps):
        local_w_list.append((i * rot_step_size))  # ccw
        local_w_list.append(-(i * rot_step_size))  # cw
    return local_w_list


def generate_global_path(x_start, y_start, theta_start, x_goal, y_goal, global_planner, max_linear_speed, max_angular_speed, dt, max_step = np.inf):
    """
        Generate a global path from start to goal, without considering obstacles.
    """
    x = x_start
    y = y_start
    theta = theta_start

    x_diff = x_goal - x
    y_diff = y_goal - y

    x_traj, y_traj, theta_traj = [], [], []
    v_traj, w_traj = [], []

    rho = np.hypot(x_diff, y_diff)
    step = 0
    while rho > 0.01 and step < max_step:
        x_traj.append(x)
        y_traj.append(y)
        theta_traj.append(theta)

        x_diff = x_goal - x
        y_diff = y_goal - y

        rho, v, w = global_planner.calc_control_command(
            x_diff, y_diff, theta)
        
        if v < max_linear_speed:
            v = np.sign(v) * max_linear_speed

        if abs(v) > max_linear_speed:
            v = np.sign(v) * max_linear_speed

        if abs(w) > max_angular_speed:
            w = np.sign(w) * max_angular_speed

        v_traj.append(v)
        w_traj.append(w)

        theta = theta + w * dt
        x = x + v * np.cos(theta) * dt
        y = y + v * np.sin(theta) * dt

        step += 1

    return x_traj, y_traj, theta_traj, v_traj, w_traj


def generate_local_path(
    x_start, y_start, theta_start, global_theta_traj, global_v_traj, global_w_traj, local_w, dt, max_linear_speed
):
    """
        Generate local path w.r.t. the global path, 
        considering the additional local angular velocity.
    """
    x = x_start
    y = y_start
    theta = theta_start

    x_traj, y_traj, theta_traj = [], [], []

    x_traj.append(x)
    y_traj.append(y)
    theta_traj.append(theta)

    global_w_traj_update = []

    for traj_idx in range(1, len(global_theta_traj)):

        # update x, y, theta
        theta = global_theta_traj[traj_idx] + local_w * dt * traj_idx  #  * self.dt  # simple integration
        # theta = global_theta_traj[traj_idx] + local_w  # * self.dt * traj_idx  #  * self.dt  # simple integration
        # x = x + global_v_traj[traj_idx] * np.cos(theta) * dt
        # y = y + global_v_traj[traj_idx] * np.sin(theta) * dt

        x = x + max_linear_speed * np.cos(theta) * dt
        y = y + max_linear_speed * np.sin(theta) * dt

        x_traj.append(x)
        y_traj.append(y)
        theta_traj.append(theta)

        # update global yaw rate
        global_w_traj_update.append(global_w_traj[traj_idx] + local_w * traj_idx)

    return x_traj, y_traj, theta_traj, global_w_traj_update


def plan_path(x_start, y_start, theta_start, x_goal, y_goal, x_path_global, y_path_global, occ_map,
              local_yaw_rate_list, occ_dilate_kernel_size, pc_range, xy_resolution, stop_distance,
              global_planner, max_linear_speed, max_angular_speed, dt, max_plan_steps, uwb_target_position=None):
    """
        Plan a path from start to goal, considering obstacles.
    """
    rho = np.inf
    max_loop = 1  
    it = 0

    local_w_list = local_yaw_rate_list

    # dilate the map
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (occ_dilate_kernel_size, occ_dilate_kernel_size))
    occ_map_dilated = cv2.dilate(occ_map, kernel, iterations=1)

    occ_map_vis = np.rot90(occ_map_dilated, k=1)
    occ_map_vis = np.flip(occ_map_vis, axis=0)

    # vis with opencv
    vis_img = (1 - occ_map_vis) * 255  # Convert to 0-255 range
    vis_img = vis_img.astype(np.uint8)
    vis_img = cv2.cvtColor(vis_img, cv2.COLOR_GRAY2BGR)
    
    # Visualize the goal position (trajectory target from VLM)
    x_goal_grid = int((x_goal - pc_range[0]) / xy_resolution)
    y_goal_grid = int((y_goal - pc_range[1]) / xy_resolution)
    cv2.circle(vis_img, (y_goal_grid, x_goal_grid), 3, (0, 200, 200), -1)  # Cyan for trajectory goal
    
    # Visualize the UWB target position (actual person location) if available
    if uwb_target_position is not None:
        x_uwb_grid = int((uwb_target_position[0] - pc_range[0]) / xy_resolution)
        y_uwb_grid = int((uwb_target_position[1] - pc_range[1]) / xy_resolution)
        cv2.circle(vis_img, (y_uwb_grid, x_uwb_grid), 5, (0, 0, 255), -1)  # Red for UWB target (person)
        cv2.circle(vis_img, (y_uwb_grid, x_uwb_grid), 7, (0, 0, 255), 2)   # Red outline for emphasis

    stop_flag = False
    v_traj_global, w_traj_update = [], []

    while rho > stop_distance and it < max_loop:
        # generate a global path
        x_traj_global, y_traj_global, theta_traj_global, v_traj_global, w_traj_global = generate_global_path(
            x_start, y_start, theta_start, x_goal, y_goal, global_planner, max_linear_speed, max_angular_speed, dt, max_step=max_plan_steps)

        x_traj_local_list, y_traj_local_list, theta_traj_local_list, w_traj_update_list = [], [], [], []
        occ_list = []

        x_traj_local_grid_list, y_traj_local_grid_list = [], []

        # generate local paths
        for local_w in local_w_list:
            x_traj_local, y_traj_local, theta_traj_local, w_traj_update = generate_local_path(
                x_start, y_start, theta_start, theta_traj_global, v_traj_global, w_traj_global, local_w, dt, max_linear_speed
            )
            x_traj_local_list.append(x_traj_local)
            y_traj_local_list.append(y_traj_local)
            theta_traj_local_list.append(theta_traj_local)
            w_traj_update_list.append(w_traj_update)

            # check collision
            x_traj_local_grid = (np.array(x_traj_local) - pc_range[0]) / xy_resolution
            y_traj_local_grid = (np.array(y_traj_local) - pc_range[1]) / xy_resolution
            check_free_res = check_collision_free(x_traj_local_grid, y_traj_local_grid, occ_map_dilated)
            occ_list.append(check_free_res)

            x_traj_local_grid_list.append(x_traj_local_grid)
            y_traj_local_grid_list.append(y_traj_local_grid)

        # sample a local path
        i = sample_path(occ_list, occ_map_dilated, x_traj_local_grid_list, y_traj_local_grid_list, use_safety_score=True)

        if i < 0: 
            print("No free path found. Turn Back.")
            stop_flag = True
            break

        else:
            stop_flag = False

            x_traj_local = x_traj_local_list[i]
            y_traj_local = y_traj_local_list[i]
            theta_traj_local = theta_traj_local_list[i]
            w_traj_update = w_traj_update_list[i]

            # update start position
            valid_traj_lens = round(len(x_traj_local) - 1)
            x_start = x_traj_local[valid_traj_lens]
            y_start = y_traj_local[valid_traj_lens]
            theta_start = theta_traj_local[valid_traj_lens]

            # update global path
            x_path_global += x_traj_local[:valid_traj_lens]
            y_path_global += y_traj_local[:valid_traj_lens]

            it += 1

    # draw all possible paths
    for idx in range(len(x_traj_local_list)):
        cur_x_traj_local = x_traj_local_list[idx]
        cur_y_traj_local = y_traj_local_list[idx]

        cur_path_points = np.array([
            [(int((y - pc_range[1]) / xy_resolution), 
              int((x - pc_range[0]) / xy_resolution)) 
             for x, y in zip(cur_x_traj_local, cur_y_traj_local)]
        ], dtype=np.int32)

        if occ_list[idx] == True:
            cv2.polylines(vis_img, cur_path_points, False, (255, 255, 0), 1) 
        else:
            cv2.polylines(vis_img, cur_path_points, False, (255, 0, 0), 1)

    if x_path_global and y_path_global:
        path_points = np.array([
            [(int((y - pc_range[1]) / xy_resolution), 
              int((x - pc_range[0]) / xy_resolution)) 
             for x, y in zip(x_path_global, y_path_global)]
        ], dtype=np.int32)
        cv2.polylines(vis_img, path_points, False, (0, 0, 255), 1)

    display_size = (300, 300)
    vis_img = cv2.resize(vis_img, display_size, interpolation=cv2.INTER_NEAREST)

    cv2.imwrite(f'/vlm_ws/viz/path/vis_img_{time.time()}.png', vis_img)
    
    return x_start, y_start, theta_start, x_path_global, y_path_global, v_traj_global, w_traj_update, stop_flag
